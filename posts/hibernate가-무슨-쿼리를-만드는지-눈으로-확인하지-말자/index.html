<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Hibernate가 무슨 쿼리를 만드는지 눈으로 확인하지 말자 | wisdoom</title>
<meta name="keywords" content="">
<meta name="description" content="JPA hibernate는 편리하지만 때로 치명적이다. 의도하지 않은 여러 쿼리가 실행돼 db에 부하가 걸리거나, 영속성 컨텍스트와 실제 db 데이터가 다를 수 있는 등의 문제가 발생할 수 있기 때문이다. 여기서는 첫 번째 문제를 보완할 수 있는 방법을 소개한다.
Hibernate가 어떤 쿼리를 생성하는지 보통은 눈으로 확인한다. 아래와 같은 로그를 보고 말이다.
[ Test worker] org.hibernate.SQL : select book0_.id as id1_0_0_ from book book0_ where book0_.id=? [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [BIGINT] - [0] 로그를 눈으로 보면 select 쿼리가 한 번 발생하는 것을 확인할 수 있다.">
<meta name="author" content="">
<link rel="canonical" href="https://Scoobi-wisdoom.github.io/posts/hibernate%EA%B0%80-%EB%AC%B4%EC%8A%A8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EB%A7%8C%EB%93%9C%EB%8A%94%EC%A7%80-%EB%88%88%EC%9C%BC%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%98%EC%A7%80-%EB%A7%90%EC%9E%90/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://Scoobi-wisdoom.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://Scoobi-wisdoom.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://Scoobi-wisdoom.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://Scoobi-wisdoom.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://Scoobi-wisdoom.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Hibernate가 무슨 쿼리를 만드는지 눈으로 확인하지 말자" />
<meta property="og:description" content="JPA hibernate는 편리하지만 때로 치명적이다. 의도하지 않은 여러 쿼리가 실행돼 db에 부하가 걸리거나, 영속성 컨텍스트와 실제 db 데이터가 다를 수 있는 등의 문제가 발생할 수 있기 때문이다. 여기서는 첫 번째 문제를 보완할 수 있는 방법을 소개한다.
Hibernate가 어떤 쿼리를 생성하는지 보통은 눈으로 확인한다. 아래와 같은 로그를 보고 말이다.
[ Test worker] org.hibernate.SQL : select book0_.id as id1_0_0_ from book book0_ where book0_.id=? [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [BIGINT] - [0] 로그를 눈으로 보면 select 쿼리가 한 번 발생하는 것을 확인할 수 있다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Scoobi-wisdoom.github.io/posts/hibernate%EA%B0%80-%EB%AC%B4%EC%8A%A8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EB%A7%8C%EB%93%9C%EB%8A%94%EC%A7%80-%EB%88%88%EC%9C%BC%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%98%EC%A7%80-%EB%A7%90%EC%9E%90/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-31T00:11:17+09:00" />
<meta property="article:modified_time" content="2022-08-31T00:11:17+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Hibernate가 무슨 쿼리를 만드는지 눈으로 확인하지 말자"/>
<meta name="twitter:description" content="JPA hibernate는 편리하지만 때로 치명적이다. 의도하지 않은 여러 쿼리가 실행돼 db에 부하가 걸리거나, 영속성 컨텍스트와 실제 db 데이터가 다를 수 있는 등의 문제가 발생할 수 있기 때문이다. 여기서는 첫 번째 문제를 보완할 수 있는 방법을 소개한다.
Hibernate가 어떤 쿼리를 생성하는지 보통은 눈으로 확인한다. 아래와 같은 로그를 보고 말이다.
[ Test worker] org.hibernate.SQL : select book0_.id as id1_0_0_ from book book0_ where book0_.id=? [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [BIGINT] - [0] 로그를 눈으로 보면 select 쿼리가 한 번 발생하는 것을 확인할 수 있다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://Scoobi-wisdoom.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Hibernate가 무슨 쿼리를 만드는지 눈으로 확인하지 말자",
      "item": "https://Scoobi-wisdoom.github.io/posts/hibernate%EA%B0%80-%EB%AC%B4%EC%8A%A8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EB%A7%8C%EB%93%9C%EB%8A%94%EC%A7%80-%EB%88%88%EC%9C%BC%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%98%EC%A7%80-%EB%A7%90%EC%9E%90/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Hibernate가 무슨 쿼리를 만드는지 눈으로 확인하지 말자",
  "name": "Hibernate가 무슨 쿼리를 만드는지 눈으로 확인하지 말자",
  "description": "JPA hibernate는 편리하지만 때로 치명적이다. 의도하지 않은 여러 쿼리가 실행돼 db에 부하가 걸리거나, 영속성 컨텍스트와 실제 db 데이터가 다를 수 있는 등의 문제가 발생할 수 있기 때문이다. 여기서는 첫 번째 문제를 보완할 수 있는 방법을 소개한다.\nHibernate가 어떤 쿼리를 생성하는지 보통은 눈으로 확인한다. 아래와 같은 로그를 보고 말이다.\n[ Test worker] org.hibernate.SQL : select book0_.id as id1_0_0_ from book book0_ where book0_.id=? [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [BIGINT] - [0] 로그를 눈으로 보면 select 쿼리가 한 번 발생하는 것을 확인할 수 있다.",
  "keywords": [
    
  ],
  "articleBody": "JPA hibernate는 편리하지만 때로 치명적이다. 의도하지 않은 여러 쿼리가 실행돼 db에 부하가 걸리거나, 영속성 컨텍스트와 실제 db 데이터가 다를 수 있는 등의 문제가 발생할 수 있기 때문이다. 여기서는 첫 번째 문제를 보완할 수 있는 방법을 소개한다.\nHibernate가 어떤 쿼리를 생성하는지 보통은 눈으로 확인한다. 아래와 같은 로그를 보고 말이다.\n[ Test worker] org.hibernate.SQL : select book0_.id as id1_0_0_ from book book0_ where book0_.id=? [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [BIGINT] - [0] 로그를 눈으로 보면 select 쿼리가 한 번 발생하는 것을 확인할 수 있다.\n이게 최선일까? 절대 아니다.\nUnit test에는 F.I.R.S.T. 원칙이 있는데, 여기서 S는 self-validating으로, 개발자가 로그를 확인해서 테스트 통과 여부를 체크하는 게 아니라, 프로그램 스스로 테스트 통과 여부를 체크하는 것을 말한다. 위의 로그 확인 방법은 이 원칙에 위배된다 (알아 안다고. 이거 unit test 아니야. 그래도 귀찮은 건 싫잖아?).\nSELECT, INSERT, UPDATE, DELETE 쿼리 중 무엇이 몇 번 발생하는지 테스트 코드로 확인 이 문제의 실마리는 datasource proxy다. Datasource proxy를 이용해 self-validating test를 만들어보자. 아래는 프로젝트 환경 설정이다.\nbuild.gradle.kts\nplugins { id(\"org.springframework.boot\") version \"2.6.11\" id(\"io.spring.dependency-management\") version \"1.0.13.RELEASE\" val kotlinVersion = \"1.6.21\" kotlin(\"jvm\") version kotlinVersion kotlin(\"plugin.spring\") version kotlinVersion kotlin(\"plugin.jpa\") version kotlinVersion } // 생략 dependencies { // 생략: data jpa, web, kotlin, database, test // self-validating query count 라이브러리. // datasource proxy를 정의하진 않지만, datasource-proxy 라이브러리에 의존한다. implementation(\"com.vladmihalcea:db-util:1.0.7\") } // 생략 엔티티\n@Entity class Book( @Id @GeneratedValue(strategy = IDENTITY) val id: Long = 0L, ) 레포지토리\ninterface BookRepository : JpaRepository 서비스\n@Service class DemoService( private val bookRepository: BookRepository, ) { @Transactional fun findBook() { bookRepository.findById(0L) } } 테스트\n@SpringBootTest @TestConstructor(autowireMode = ALL) internal class DemoServiceTest( private val demoService: DemoService, ) { @Test fun a() { // 쿼리 기록 삭제 SQLStatementCountValidator.reset() demoService.findBook() // select 쿼리 개수 체크 SQLStatementCountValidator.assertSelectCount(1) } } 테스트 코드가 매우 직관적이다. 하지만 테스트는 아래와 같이 실패한다. 떡하니 쿼리도 로그에 나와서 약오른다.\n2022-08-30 23:59:12.180 DEBUG 17105 --- [ Test worker] org.hibernate.SQL : select book0_.id as id1_0_0_ from book book0_ where book0_.id=? 2022-08-30 23:59:12.183 TRACE 17105 --- [ Test worker] o.h.type.descriptor.sql.BasicBinder : binding parameter [1] as [BIGINT] - [0] Expected 1 statements but recorded 0 instead! com.vladmihalcea.sql.exception.SQLSelectCountMismatchException: Expected 1 statements but recorded 0 instead! 해결 방법은 서두에서 언급한 것처럼 datasource-proxy다. 아래와 같이 component bean을 설정하자.\n@Component class DatasourceProxyBeanPostProcessor : BeanPostProcessor { override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any { return bean } override fun postProcessAfterInitialization(bean: Any, beanName: String): Any { return if (bean is DataSource) { ProxyDataSourceBuilder.create(bean) .logQueryBySlf4j(INFO) .multiline() .countQuery() .build() } else bean } } 이제 테스트를 실행하면 성공한다.\n위 방법은 N+1 같은 문제를 감지하는 데 좋다. 하지만 가끔은 쿼리의 종류뿐만 아니라 쿼리문 전체를 확인하고 싶을 때도 있다. 이 때는 어덯게 해야 할까? 눈으로 확인해야 할까?\n쿼리문 자체를 String 비교를 통해 테스트 코드로 확인 Hibernate가 만들어내는 쿼리를 string으로 변환하고, 이를 테스트 코드로 확인할 수 있다. 여기서도 datasource proxy를 사용한다. 아래는 프로젝트 설정이다.\nbuild.gradle.kts\nplugins { id(\"org.springframework.boot\") version \"2.6.11\" id(\"io.spring.dependency-management\") version \"1.0.13.RELEASE\" val kotlinVersion = \"1.6.21\" kotlin(\"jvm\") version kotlinVersion kotlin(\"plugin.spring\") version kotlinVersion kotlin(\"plugin.jpa\") version kotlinVersion } // 생략 dependencies { // 생략: data jpa, web, kotlin, database, test // datasource proxy를 정의. implementation(\"net.ttddyy:datasource-assert:1.0\") } 엔티티와 레포지토리는 위와 동일하다.\n서비스\n@Service class DemoService( private val bookRepository: BookRepository, ) { @Transactional fun findBook() { bookRepository.findById(0L) } @Transactional fun findAllBook(){ bookRepository.findAll() } } Proxy datasource를 사용하기 위해 테스트 패키지에 다음과 같이 테스트 환경설정을 한다. ProxyDataSourceConfig\n@TestConfiguration class ProxyDataSourceConfig : BeanPostProcessor { override fun postProcessAfterInitialization(bean: Any, beanName: String): Any { return if (bean is DataSource) { return ProxyTestDataSource(bean) } else bean } } 테스트\n@SpringBootTest @Import(ProxyDataSourceConfig::class) @TestConstructor(autowireMode = ALL) internal class DemoServiceTest( private val dataSource: ProxyTestDataSource, private val demoService: DemoService, ) { @AfterEach fun tearDown() { dataSource.reset() } @Test fun findAllBook() { demoService.findAllBook() val actual = dataSource.queryExecutions .map { it as PreparedExecution it.query }[0] val expected = \"\"\" select book0_.id as id1_0_, book0_.body as body2_0_ from book book0_ \"\"\" .trimIndent() .replaceWithSingleWhiteSpace() assertTrue(actual == expected) } private fun String.replaceWithSingleWhiteSpace(): String { return this.replace(\"\\\\s+\".toRegex(), \" \") } @Test fun findBook() { demoService.findBook() val actual = dataSource.queryExecutions .map { it as PreparedExecution it.query }[0] val expected = \"\"\" select book0_.id as id1_0_0_, book0_.body as body2_0_0_ from book book0_ where book0_.id=? \"\"\" .trimIndent() .replaceWithSingleWhiteSpace() assertTrue(actual == expected) } } 위 테스트는 hibernate가 생성하는 쿼리를 string으로 놓고 비교한다. 그렇기 때문에 서비스 코드가 변경돼 쿼리도 달라진다면 이를 테스트로 알 수 있다.\nReferences Anghel Leonard. (2020) Spring Boot Persistence Best Practices (1st ed.). Apress Configuring A Datasource-Proxy In Spring Boot, Arnold Galovics - ARNOLD GALOVICS datasource-assert, Tadaya Tsuyukubo - github Testing with Spring Boot’s @TestConfiguration Annotation ",
  "wordCount" : "727",
  "inLanguage": "en",
  "datePublished": "2022-08-31T00:11:17+09:00",
  "dateModified": "2022-08-31T00:11:17+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://Scoobi-wisdoom.github.io/posts/hibernate%EA%B0%80-%EB%AC%B4%EC%8A%A8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EB%A7%8C%EB%93%9C%EB%8A%94%EC%A7%80-%EB%88%88%EC%9C%BC%EB%A1%9C-%ED%99%95%EC%9D%B8%ED%95%98%EC%A7%80-%EB%A7%90%EC%9E%90/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "wisdoom",
    "logo": {
      "@type": "ImageObject",
      "url": "https://Scoobi-wisdoom.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://Scoobi-wisdoom.github.io/" accesskey="h" title="wisdoom (Alt + H)">wisdoom</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Hibernate가 무슨 쿼리를 만드는지 눈으로 확인하지 말자
    </h1>
    <div class="post-meta"><span title='2022-08-31 00:11:17 +0900 KST'>August 31, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>JPA hibernate는 편리하지만 때로 치명적이다. 의도하지 않은 여러 쿼리가 실행돼 db에 부하가 걸리거나, 영속성 컨텍스트와 실제 db 데이터가 다를 수 있는 등의 문제가 발생할 수 있기 때문이다. 여기서는 첫 번째 문제를 보완할 수 있는 방법을 소개한다.</p>
<p>Hibernate가 어떤 쿼리를 생성하는지 보통은 눈으로 확인한다. 아래와 같은 로그를 보고 말이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>[    Test worker] org.hibernate.SQL                        : select book0_.id as id1_0_0_ from book book0_ where book0_.id=?
</span></span><span style="display:flex;"><span>[    Test worker] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [BIGINT] - [0]
</span></span></code></pre></div><p>로그를 눈으로 보면 <code>select</code> 쿼리가 한 번 발생하는 것을 확인할 수 있다.</p>
<p>이게 최선일까? 절대 아니다.</p>
<p>Unit test에는 F.I.R.S.T. 원칙이 있는데, 여기서 S는 self-validating으로, 개발자가 로그를 확인해서 테스트 통과 여부를 체크하는 게 아니라, 프로그램 스스로 테스트 통과 여부를 체크하는 것을 말한다. 위의 로그 확인 방법은 이 원칙에 위배된다 (알아 안다고. 이거 unit test 아니야. 그래도 귀찮은 건 싫잖아?).</p>
<h1 id="select-insert-update-delete-쿼리-중-무엇이-몇-번-발생하는지-테스트-코드로-확인">SELECT, INSERT, UPDATE, DELETE 쿼리 중 무엇이 몇 번 발생하는지 테스트 코드로 확인<a hidden class="anchor" aria-hidden="true" href="#select-insert-update-delete-쿼리-중-무엇이-몇-번-발생하는지-테스트-코드로-확인">#</a></h1>
<p>이 문제의 실마리는 datasource proxy다. Datasource proxy를 이용해 self-validating test를 만들어보자. 아래는 프로젝트 환경 설정이다.</p>
<p>build.gradle.kts</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>plugins {
</span></span><span style="display:flex;"><span>	id(<span style="color:#e6db74">&#34;org.springframework.boot&#34;</span>) version <span style="color:#e6db74">&#34;2.6.11&#34;</span>
</span></span><span style="display:flex;"><span>	id(<span style="color:#e6db74">&#34;io.spring.dependency-management&#34;</span>) version <span style="color:#e6db74">&#34;1.0.13.RELEASE&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">val</span> kotlinVersion = <span style="color:#e6db74">&#34;1.6.21&#34;</span>
</span></span><span style="display:flex;"><span>	kotlin(<span style="color:#e6db74">&#34;jvm&#34;</span>) version kotlinVersion
</span></span><span style="display:flex;"><span>	kotlin(<span style="color:#e6db74">&#34;plugin.spring&#34;</span>) version kotlinVersion
</span></span><span style="display:flex;"><span>	kotlin(<span style="color:#e6db74">&#34;plugin.jpa&#34;</span>) version kotlinVersion
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 생략
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>dependencies {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 생략: data jpa, web, kotlin, database, test
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// self-validating query count 라이브러리.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// datasource proxy를 정의하진 않지만, datasource-proxy 라이브러리에 의존한다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	implementation(<span style="color:#e6db74">&#34;com.vladmihalcea:db-util:1.0.7&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 생략
</span></span></span></code></pre></div><p>엔티티</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@Entity</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Book</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Id</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@GeneratedValue</span>(strategy = IDENTITY)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> id: Long = <span style="color:#ae81ff">0L</span>,
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>레포지토리</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">BookRepository</span> : JpaRepository&lt;Book, Long&gt;
</span></span></code></pre></div><p>서비스</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DemoService</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> bookRepository: BookRepository,
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">findBook</span>() {
</span></span><span style="display:flex;"><span>        bookRepository.findById(<span style="color:#ae81ff">0L</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>테스트</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@SpringBootTest</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@TestConstructor</span>(autowireMode = ALL)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DemoServiceTest</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> demoService: DemoService,
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">a</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 쿼리 기록 삭제
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">SQLStatementCountValidator</span>.reset()
</span></span><span style="display:flex;"><span>        demoService.findBook()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// select 쿼리 개수 체크
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">SQLStatementCountValidator</span>.assertSelectCount(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>테스트 코드가 매우 직관적이다. 하지만 테스트는 아래와 같이 실패한다. 떡하니 쿼리도 로그에 나와서 약오른다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>2022-08-30 23:59:12.180 DEBUG 17105 --- [    Test worker] org.hibernate.SQL                        : select book0_.id as id1_0_0_ from book book0_ where book0_.id=?
</span></span><span style="display:flex;"><span>2022-08-30 23:59:12.183 TRACE 17105 --- [    Test worker] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [BIGINT] - [0]
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>Expected 1 statements but recorded 0 instead!
</span></span><span style="display:flex;"><span>com.vladmihalcea.sql.exception.SQLSelectCountMismatchException: Expected 1 statements but recorded 0 instead!
</span></span></code></pre></div><p>해결 방법은 서두에서 언급한 것처럼 datasource-proxy다. 아래와 같이 component bean을 설정하자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@Component</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DatasourceProxyBeanPostProcessor</span> : BeanPostProcessor {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">postProcessBeforeInitialization</span>(bean: Any, beanName: String): Any {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> bean
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">postProcessAfterInitialization</span>(bean: Any, beanName: String): Any {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> (bean <span style="color:#66d9ef">is</span> DataSource) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ProxyDataSourceBuilder</span>.create(bean)
</span></span><span style="display:flex;"><span>                .logQueryBySlf4j(INFO)
</span></span><span style="display:flex;"><span>                .multiline()
</span></span><span style="display:flex;"><span>                .countQuery()
</span></span><span style="display:flex;"><span>                .build()
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> bean
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이제 테스트를 실행하면 성공한다.</p>
<p>위 방법은 N+1 같은 문제를 감지하는 데 좋다. 하지만 가끔은 쿼리의 종류뿐만 아니라 쿼리문 전체를 확인하고 싶을 때도 있다. 이 때는 어덯게 해야 할까? 눈으로 확인해야 할까?</p>
<h1 id="쿼리문-자체를-string-비교를-통해-테스트-코드로-확인">쿼리문 자체를 String 비교를 통해 테스트 코드로 확인<a hidden class="anchor" aria-hidden="true" href="#쿼리문-자체를-string-비교를-통해-테스트-코드로-확인">#</a></h1>
<p>Hibernate가 만들어내는 쿼리를 string으로 변환하고, 이를 테스트 코드로 확인할 수 있다. 여기서도 datasource proxy를 사용한다. 아래는 프로젝트 설정이다.</p>
<p>build.gradle.kts</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>plugins {
</span></span><span style="display:flex;"><span>	id(<span style="color:#e6db74">&#34;org.springframework.boot&#34;</span>) version <span style="color:#e6db74">&#34;2.6.11&#34;</span>
</span></span><span style="display:flex;"><span>	id(<span style="color:#e6db74">&#34;io.spring.dependency-management&#34;</span>) version <span style="color:#e6db74">&#34;1.0.13.RELEASE&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">val</span> kotlinVersion = <span style="color:#e6db74">&#34;1.6.21&#34;</span>
</span></span><span style="display:flex;"><span>	kotlin(<span style="color:#e6db74">&#34;jvm&#34;</span>) version kotlinVersion
</span></span><span style="display:flex;"><span>	kotlin(<span style="color:#e6db74">&#34;plugin.spring&#34;</span>) version kotlinVersion
</span></span><span style="display:flex;"><span>	kotlin(<span style="color:#e6db74">&#34;plugin.jpa&#34;</span>) version kotlinVersion
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 생략
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>dependencies {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 생략: data jpa, web, kotlin, database, test
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// datasource proxy를 정의.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	implementation(<span style="color:#e6db74">&#34;net.ttddyy:datasource-assert:1.0&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>엔티티와 레포지토리는 위와 동일하다.</p>
<p>서비스</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@Service</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DemoService</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> bookRepository: BookRepository,
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">findBook</span>() {
</span></span><span style="display:flex;"><span>        bookRepository.findById(<span style="color:#ae81ff">0L</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Transactional</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">findAllBook</span>(){
</span></span><span style="display:flex;"><span>        bookRepository.findAll()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Proxy datasource를 사용하기 위해 테스트 패키지에 다음과 같이 테스트 환경설정을 한다.
ProxyDataSourceConfig</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@TestConfiguration</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProxyDataSourceConfig</span> : BeanPostProcessor {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">postProcessAfterInitialization</span>(bean: Any, beanName: String): Any {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> (bean <span style="color:#66d9ef">is</span> DataSource) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> ProxyTestDataSource(bean)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> bean
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>테스트</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@SpringBootTest</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Import</span>(ProxyDataSourceConfig<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@TestConstructor</span>(autowireMode = ALL)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DemoServiceTest</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> dataSource: ProxyTestDataSource,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> demoService: DemoService,
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@AfterEach</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">tearDown</span>() {
</span></span><span style="display:flex;"><span>        dataSource.reset()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">findAllBook</span>() {
</span></span><span style="display:flex;"><span>        demoService.findAllBook()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> actual = dataSource.queryExecutions
</span></span><span style="display:flex;"><span>            .map {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">it</span> <span style="color:#66d9ef">as</span> PreparedExecution
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">it</span>.query
</span></span><span style="display:flex;"><span>            }[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> expected =
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            select
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            book0_.id as id1_0_,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            book0_.body as body2_0_
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            from book book0_
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>                .trimIndent()
</span></span><span style="display:flex;"><span>                .replaceWithSingleWhiteSpace()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        assertTrue(<span style="color:#66d9ef">actual</span> <span style="color:#f92672">==</span> expected)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">String</span>.replaceWithSingleWhiteSpace(): String {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.replace(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">s+&#34;</span>.toRegex(), <span style="color:#e6db74">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">findBook</span>() {
</span></span><span style="display:flex;"><span>        demoService.findBook()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> actual = dataSource.queryExecutions
</span></span><span style="display:flex;"><span>            .map {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">it</span> <span style="color:#66d9ef">as</span> PreparedExecution
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">it</span>.query
</span></span><span style="display:flex;"><span>            }[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> expected =
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            select
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            book0_.id as id1_0_0_,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            book0_.body as body2_0_0_
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            from book book0_
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            where book0_.id=?
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>                .trimIndent()
</span></span><span style="display:flex;"><span>                .replaceWithSingleWhiteSpace()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        assertTrue(<span style="color:#66d9ef">actual</span> <span style="color:#f92672">==</span> expected)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>위 테스트는 hibernate가 생성하는 쿼리를 string으로 놓고 비교한다. 그렇기 때문에 서비스 코드가 변경돼 쿼리도 달라진다면 이를 테스트로 알 수 있다.</p>
<h3 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h3>
<ul>
<li>Anghel Leonard. (2020) Spring Boot Persistence Best Practices (1st ed.). Apress</li>
<li><a href="https://arnoldgalovics.com/spring-boot-datasource-proxy/">Configuring A Datasource-Proxy In Spring Boot, Arnold Galovics - ARNOLD GALOVICS
</a></li>
<li><a href="https://github.com/ttddyy/datasource-assert">datasource-assert, Tadaya Tsuyukubo - github</a></li>
<li><a href="https://reflectoring.io/spring-boot-testconfiguration/">Testing with Spring Boot’s @TestConfiguration Annotation</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://Scoobi-wisdoom.github.io/">wisdoom</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
