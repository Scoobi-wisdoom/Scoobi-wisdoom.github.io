<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kotlin Coroutines | wisdoom</title>
<meta name="keywords" content="">
<meta name="description" content="왜 coroutine 을 사용해야 할까? Kotlin coroutine 은 효율적으로 thread 를 사용하고, 프로그래머가 편하고, 퍼포먼스가 좋다.
효율적으로 thread 를 사용한다 Thread 를 생성하는 데에는 큰 비용이 든다. 그런데 Coroutine 를 사용하기 위해 추가적인 thread 생성이 필요 없다.
또한 coroutine 은 non-blocking 이다. 즉, coroutine 이 완료될 때까지 thread 가 멈춰있지 않고 다른 작업을 처리할 수 있다. 아래 예시를 보자.
fun showOrderInfo(details: Details) = async { val orderId = orderProduct(details).await() val orderData = loadOrderData(orderId).">
<meta name="author" content="">
<link rel="canonical" href="https://Scoobi-wisdoom.github.io/posts/kotlin-coroutines/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://Scoobi-wisdoom.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://Scoobi-wisdoom.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://Scoobi-wisdoom.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://Scoobi-wisdoom.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://Scoobi-wisdoom.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Kotlin Coroutines" />
<meta property="og:description" content="왜 coroutine 을 사용해야 할까? Kotlin coroutine 은 효율적으로 thread 를 사용하고, 프로그래머가 편하고, 퍼포먼스가 좋다.
효율적으로 thread 를 사용한다 Thread 를 생성하는 데에는 큰 비용이 든다. 그런데 Coroutine 를 사용하기 위해 추가적인 thread 생성이 필요 없다.
또한 coroutine 은 non-blocking 이다. 즉, coroutine 이 완료될 때까지 thread 가 멈춰있지 않고 다른 작업을 처리할 수 있다. 아래 예시를 보자.
fun showOrderInfo(details: Details) = async { val orderId = orderProduct(details).await() val orderData = loadOrderData(orderId)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Scoobi-wisdoom.github.io/posts/kotlin-coroutines/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-26T00:41:11+09:00" />
<meta property="article:modified_time" content="2023-09-26T00:41:11+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kotlin Coroutines"/>
<meta name="twitter:description" content="왜 coroutine 을 사용해야 할까? Kotlin coroutine 은 효율적으로 thread 를 사용하고, 프로그래머가 편하고, 퍼포먼스가 좋다.
효율적으로 thread 를 사용한다 Thread 를 생성하는 데에는 큰 비용이 든다. 그런데 Coroutine 를 사용하기 위해 추가적인 thread 생성이 필요 없다.
또한 coroutine 은 non-blocking 이다. 즉, coroutine 이 완료될 때까지 thread 가 멈춰있지 않고 다른 작업을 처리할 수 있다. 아래 예시를 보자.
fun showOrderInfo(details: Details) = async { val orderId = orderProduct(details).await() val orderData = loadOrderData(orderId)."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://Scoobi-wisdoom.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kotlin Coroutines",
      "item": "https://Scoobi-wisdoom.github.io/posts/kotlin-coroutines/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kotlin Coroutines",
  "name": "Kotlin Coroutines",
  "description": "왜 coroutine 을 사용해야 할까? Kotlin coroutine 은 효율적으로 thread 를 사용하고, 프로그래머가 편하고, 퍼포먼스가 좋다.\n효율적으로 thread 를 사용한다 Thread 를 생성하는 데에는 큰 비용이 든다. 그런데 Coroutine 를 사용하기 위해 추가적인 thread 생성이 필요 없다.\n또한 coroutine 은 non-blocking 이다. 즉, coroutine 이 완료될 때까지 thread 가 멈춰있지 않고 다른 작업을 처리할 수 있다. 아래 예시를 보자.\nfun showOrderInfo(details: Details) = async { val orderId = orderProduct(details).await() val orderData = loadOrderData(orderId).",
  "keywords": [
    
  ],
  "articleBody": "왜 coroutine 을 사용해야 할까? Kotlin coroutine 은 효율적으로 thread 를 사용하고, 프로그래머가 편하고, 퍼포먼스가 좋다.\n효율적으로 thread 를 사용한다 Thread 를 생성하는 데에는 큰 비용이 든다. 그런데 Coroutine 를 사용하기 위해 추가적인 thread 생성이 필요 없다.\n또한 coroutine 은 non-blocking 이다. 즉, coroutine 이 완료될 때까지 thread 가 멈춰있지 않고 다른 작업을 처리할 수 있다. 아래 예시를 보자.\nfun showOrderInfo(details: Details) = async { val orderId = orderProduct(details).await() val orderData = loadOrderData(orderId).await() showData(orderData) } 위 예시에서 orderProduct() 와 loadOrderData() 는 suspend fun 로서, non-blocking 이다. 덕분에 thread 는 showOrderInfo() 함수 말고도 다른 작업을 할 수 있다. 만약 orderProduct() 와 loadOrderData() 가 blocking 이라면, thread 는 두 함수가 완료될 때까지 다른 작업을 할 수 없다.\n프로그래머가 편하다 Coroutine 을 사용하는 함수를 정의할 때 suspend modifier 만 붙이면 된다. 그렇기 때문에 레거시 코드에 coroutine 을 도입할 때도 작업량이 적다.\ncallback 을 짤 필요가 없어서 코드의 가독성이 좋다. 후술하겠지만, 사실 Kotlin coroutine 은 callback 을 사용한다.\n퍼포먼스가 좋다 Thread 를 생성하는 로직과 Thread 생성 없이 coroutine 을 실행하는 것의 성능 차이를 보자. 아래는 Marcin Moskała 의 Kotlin Coroutines Deep Dive 예시를 각색한 것이다.\nfun repeatWithThread() { val timeSpent = measureTimeMillis { repeat(400_000) { thread { Thread.sleep(1500L) } } } println(\"Repeating with threads spent $timeSpent milliseconds.\") } Repeating with threads spent 101091 milliseconds. fun repeatWithCoroutine() = runBlocking { val timeSpent = measureTimeMillis { repeat(400_000) { launch { delay(1500L) } } } println(\"Repeating with coroutines spent $timeSpent milliseconds.\") } Repeating with coroutines spent 178 milliseconds. 보다시피 thread 를 만드는 방식은 coroutine 을 사용하는 것보다 시간이 훨씬 많이 걸린다. 또한 thread 를 만들면서 OOM 이 발생할 수도 있다. 그러면 이미 thread pool 이 만들어진 상황에서는 어떨까? 아래를 보자.\nfun repeatWithThreadPool() { val threadPool = List(400_000) { thread { Thread.sleep(1500L) } } val timeSpent = measureTimeMillis { threadPool.forEach { it.join() } } println(\"Repeating with threads spent $timeSpent milliseconds.\") } Repeating with threads spent 2557 milliseconds. 위에서 확인할 수 있듯이, thread pool 을 만드는 시간을 재지 않았음에도 작업마다 thread 를 할당하는 방식은 coroutine 을 사용하는 방식보다 느리다.\n기본 개념 Marcin Moskała 의 Kotlin Coroutines Deep Dive 에서 아래와 같이 coroutines 를 정의한다.\nBy definition, coroutines are components that can be suspended and resumed.\nKotlin coroutine 은 suspend, resume 이 가능하며 이 때의 동작은 non-blocking 이다. 또한 프로그래머는 어떤 thread 에서 coroutine 을 구동할지 선택할 수 있다.\n동작 예시: sequence 아래는 Marcin Moskała 의 Kotlin Coroutines Deep Dive 예시다.\nclass CoroutineInSequence { fun showHowCoroutineWorks() { val seq = sequence { println(\"Generating first\") yield(1) println(\"Generating second\") yield(2) println(\"Generating third\") yield(3) println(\"Done\") } for (num in seq) { println(\"the next number is $num\") } } } 함수 showHowCoroutineWorks() 를 실행하면 아래와 같은 동작을 확인할 수 있다.\nGenerating first the next number is 1 Generating second the next number is 2 Generating third the next number is 3 Done 이를 통해 for-loop block 이 실행될 때마다 yield() 함수에서 코루틴이 멈추고 (suspend) 재개하는 (resume) 것을 확인할 수 있다.\n참고로 suspend 대상은 함수가 아닌 coroutine 이라는 것을 잊으면 안 된다. 함수가 멈추는 것처럼 보여도, 이건 함수가 coroutine 을 멈춘 것이다.\n동작 원리: Continuation interface Callback 과 유사하다 Coroutine 은 어떻게 함수 중간에 실행을 멈추고, 나중에 멈춘 부분부터 실행할 수 있을까? Kotlin coroutines 의 동작 방식은 callback 과 유사하다. 하지만 Kotlin coroutine 은 thread 를 점유하지 않기 위해 call stack 을 비워버린다. 그렇기 때문에 call stack 의 대체제가 필요하다. 이는 continuations 에 의해 달성된다.\n알다시피, suspend fun 은 suspension 과 resume 이 가능하다. 이를 위해서 기록돼야 하는 것들은 어느 함수 어느 위치에서 suspension 이 일어났는지, local variables, parameters 등이다. 당연한 얘기지만 이 정보를 갖고 resume 을 한다. 이 정보는 모두 Continuation object 에 저장된다.\nKoltin compiler 는 suspend fun 에 Continuation interface 를 parameter 로 추가한다. Coninuation 은 general callback interface 다. 이는 IntelliJ 에서 kotlin code 를 java 로 변환해서 쉽게 확인할 수 있다.\nkotlin 코드\nsuspend fun showContinuationParameter() { } java 로 변환\npublic final class SuspendFunctionPracticeKt { @Nullable public static final Object showContinuationParameter(@NotNull Continuation $completion) { return Unit.INSTANCE; } } 위 코드를 보면 suspend fun 에는 Continuation 이 있음을 알 수 있다.\ncontinuation callback 절차 Continuation 의 callback 절차는 다음과 같다.\ncontinuation resume 시작 Resumed continuation 이 관련 함수를 호출 위 continuation 이 다른 continuation 을 resume 시킴 위 절차가 연쇄적으로 일어난다. 아래 예시를 보자 (Marcin Moskała 의 Kotlin Coroutines Deep Dive 예시).\nsuspend fun a() { val user = readUser() b() b() b() println(user) } suspend fun b() { for (i in 1..10) { c(i) } } suspend fun c(i: Int) { delay(i * 100L) println(\"Tick\") } 위 코드에서 c 를 resume 하는 경우를 예로 들면 아래와 같은 절차가 연쇄적으로 일어난다.\nCContinuation.resume 호출 CContinuation.resume 이 c() 호출 c() 가 완료되면 CContinuation.resume 이 BContinuation.resume 호출 동일한 절차로 AContinuation 까지 진행된다.\nConvention: suspend vs. extension Svetlana Isakova 는 suspend 함수를 언제 쓰고, 언제 CoroutineScope extension function 을 사용할지를 정한다. 반환 값을 즉시 확인하고자 할 때는 suspend fun 을 정의하고, 반환 값에 관심이 없거나 즉시 확인할 필요가 없을 때는 CoroutineScope 의 extension function 을 정의한다. 아래와 같이 말이다.\nsuspend fun orderProduct(details: details): ProductId fun CoroutineScope.loadProductInformationAsync( productName: String ): Deferred Basic example class CoroutineBasic { fun executeMultipleCoroutine() { GlobalScope.launch { launch { delay(300L) println(\"1st scope: 1st coroutine\") } launch { delay(100L) println(\"1st scope: 2nd coroutine\") } } GlobalScope.launch { println(\"2nd scope: 1st println\") println(\"2nd scope: 2nd println\") } } } executeMultipleCoroutine 를 실행하면 다음과 같은 결과를 얻는다.\n2nd scope: 1st println 2nd scope: 2nd println 1st scope: 2nd coroutine 1st scope: 1st coroutine 즉, launch 함수 내에서는 synchronous, launch 함수끼리는 asynchronous 다.\nlaunch vs. async Coroutine builders 에는 launch, async 가 있다. launch 는 Job 을 반환하고, async 는 Deferred 를 반환한다. 어떤 경우에 launch, async 를 각각 사용해야 할까? 실행의 결과를 확인해야 하면 async 를, 실행만 하려면 launch 를 쓴다.\n적용 사례 Philipp Lackner 가 youtube 에서 언급한 내용을 정리했다.\n예외 전파: Exceptions in child coroutines propagate to the parent 코틀린 코루틴을 사용할 때 예외 처리가 헷갈릴 수 있다. 아래 두 함수를 보자.\nclass CoroutineError { fun throwInsideCurrentCoroutine() { GlobalScope.launch { try { throw Exception(\"exception.\") } catch (e: Exception) { println(\"Exception has been caught: $e\") } } } fun throwOutsideCurrentCoroutine() { GlobalScope.launch { try { launch { throw Exception(\"child coroutine exception thrown.\") } } catch (e: Exception) { println(\"Exception has been caught: $e\") } } } } throwInsideCurrentCoroutine 와 throwOutsideCurrentCoroutine 의 차이는 예외가 어디서 발생했느냐다. 전자는 try-catch 문이 속한 context 에서 예외가 발생하지만, 후자는 try-catch 가 속하지 않은 context 에서 예외가 발생한다. 그렇기 때문에 각 함수를 실행해보면 각각 아래와 같은 메시지를 확인할 수 있다.\n함수 throwInsideCurrentCoroutine 실행: catch 성공\nException has been caught: java.lang.Exception: nested exception. 함수 throwOutsideCurrentCoroutine 실행: catch 실패\nException in thread \"DefaultDispatcher-worker-2\" java.lang.Exception: child coroutine exception thrown. at CoroutineError$throwOutsideCurrentCoroutine$1$1.invokeSuspend(CoroutineError.kt:19) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684) Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@792a55e5, Dispatchers.Default] 함수 throwOutsideCurrentCoroutine 에서 왜 catch 가 실패할까? 이유는 서로 coroutine 이 다르기 때문이다. 코드에서 try 문 안에 launch 함수를 사용해 독립적인 coroutine 을 만들었고, 거기서 예외가 발생했으니 parent coroutine 로 propagation 이 일어나고, 이로 인해 catch 실패가 일어난다.\nlaunch 말고 async 는 어떨까? async 는 await 를 호출했을 때 async 내에서 발생한 exception 을 던진다. 그렇다면 아래 throwAsyncExceptionInLaunch 함수는 exception 을 던지면 안 될 거 같다.\nclass AsyncExceptionPractice { fun throwAsyncExceptionInLaunch() { GlobalScope.launch { val networkResponse = async { delay(500L) throw Exception() \"result\" } // No matter whether you comment this out, an exception occurs // networkResponse.await() } } fun throwAsyncExceptionInAsync() { GlobalScope.async { val networkResponse = async { delay(500L) throw Exception() \"result\" } // No matter whether you comment this out, an exception does not occur // networkResponse.await() } } } 하지만 throwAsyncExceptionInLaunch 함수를 호출하면 아래와 같이 exception 이 발생한다.\nException in thread \"DefaultDispatcher-worker-2\" java.lang.Exception at AsyncExceptionPractice$throwAsyncExceptionInLaunch$1$networkResponse$1.invokeSuspend(AsyncExceptionPractice.kt:11) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684) Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@45e5831c, Dispatchers.Default] 왜 그럴까? 함수 throwAsyncExceptionInLaunch 에서 async coroutine 이 launch coroutine 의 child 이기 때문이다. 다시 말하면, launch coroutine 으로 async coroutine 의 예외가 전파되고, launch 는 async 와 달리 즉시 예외를 던지기 때문이다.\n만약 parent coroutine 이 async 에 의해 시작되는 throwAsyncExceptionInAsync 를 호출하면 어떤 일이 일어날까? 예외는 발생하지 않는다. 이는 위에서 서술한 async 의 성격과 관련이 있다.\nsupervisorScope: No propagation Coroutine scope 는 propagation 방식에 따라 두 가지로 나뉜다. 하나는 (normal) coroutine scope, 다른 하나는 supervisor coroutine scope 이다. 보통의 coroutine scope 에서 예외가 발생하면 child coroutines 를 모두 취소하고 해당 coroutine scope 역시 취소된다. supervisorScope 는 child coroutine 의 예외가 전파되지 않는다.\nclass ExceptionPropagationControl { fun doNotPropagate() { GlobalScope.launch { supervisorScope { launch { delay(300L) println(\"1st coroutine.\") throw Exception() } launch { delay(500L) println(\"2nd coroutine.\") } } } } fun doPropagate() { GlobalScope.launch { coroutineScope { launch { delay(300L) println(\"1st coroutine.\") throw Exception() } launch { delay(500L) println(\"2nd coroutine.\") } } } } } supervisorScope 를 사용하는 doNotPropagate() 함수를 호출하면 child coroutine 의 예외가 전파되지 않는 것을 아래에서 확인할 수 있다.\n1st coroutine. Exception in thread \"DefaultDispatcher-worker-2\" java.lang.Exception at ExceptionPropagationControl$doNotPropagate$1$1$1.invokeSuspend(ExceptionPropagationControl.kt:19) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684) Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@386429a2, Dispatchers.Default] 2nd coroutine. 반대로 coroutineScope 를 사용하는 doPropagate() 함수를 호출하면 아래와 같이 예외가 전파돼 다른 child coroutine 이 완료되지 않는다.\n1st coroutine. Exception in thread \"DefaultDispatcher-worker-2\" java.lang.Exception at ExceptionPropagationControl$doPropagate$1$1$1.invokeSuspend(ExceptionPropagationControl.kt:36) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33) at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108) at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697) at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684) Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@52d8bbd8, Dispatchers.Default] cancellation bad practice 아래 코드를 보면 cancel() 을 통해 targetJob 이 취소됨을 알 수 있다.\nclass CoroutineCancellation { fun cancelJobDuringExecution() { GlobalScope.launch { val targetJob = launch { try { delay(500L) } catch (e: Exception) { e.printStackTrace() } println(\"job has been done.\") } delay(300L) targetJob.cancel() } } } kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine{Cancelling}@25f78d6e job has been done. 위에서 cancel() 함수는 targetJob 을 300ms 후에 취소한다. targetJob 이 println(\"job has been done.\") 을 실행하기 위해서는 500ms 가 필요하다. 그런데 이상하게도 console 은 “job has been done.” 를 출력한다. 왜 그럴까? cancel() 로 인해 CancellationException 이 발생하고, 이게 catch block 에서 잡히기 때문이다. cancel() 은 suspend 함수를 취소하는데, 위에서는 delay(500L) 이 취소된다. delay(500L) 이 취소되면서 CancellationException 이 발생하고, 이건 다시 catch block 에 의해 처리된다. 예외가 catch block 에서 잡혔기 때문에 parent coroutine 으로 예외는 전파되지 않는다. 그렇기 때문에 println(\"job has been done.\") 이 실행되 자원이 낭비된다.\nReferences Marcin Moskała. (2023) Kotlin Coroutines Deep Dive. Leanpub Kotlin Coroutines, Google Developer Groups - Youtube In-Depth Guide to Coroutine Cancellation \u0026 Exception Handling - Android Studio Tutorial, Philipp Lackner - Youtube ",
  "wordCount" : "1688",
  "inLanguage": "en",
  "datePublished": "2023-09-26T00:41:11+09:00",
  "dateModified": "2023-09-26T00:41:11+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://Scoobi-wisdoom.github.io/posts/kotlin-coroutines/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "wisdoom",
    "logo": {
      "@type": "ImageObject",
      "url": "https://Scoobi-wisdoom.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://Scoobi-wisdoom.github.io/" accesskey="h" title="wisdoom (Alt + H)">wisdoom</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Kotlin Coroutines
    </h1>
    <div class="post-meta"><span title='2023-09-26 00:41:11 +0900 KST'>September 26, 2023</span>

</div>
  </header> 
  <div class="post-content"><h1 id="왜-coroutine-을-사용해야-할까">왜 coroutine 을 사용해야 할까?<a hidden class="anchor" aria-hidden="true" href="#왜-coroutine-을-사용해야-할까">#</a></h1>
<p>Kotlin coroutine 은 효율적으로 thread 를 사용하고, 프로그래머가 편하고, 퍼포먼스가 좋다.</p>
<h2 id="효율적으로-thread-를-사용한다">효율적으로 thread 를 사용한다<a hidden class="anchor" aria-hidden="true" href="#효율적으로-thread-를-사용한다">#</a></h2>
<p>Thread 를 생성하는 데에는 큰 비용이 든다. 그런데 Coroutine 를 사용하기 위해 추가적인 <strong>thread 생성이 필요 없다</strong>.</p>
<p>또한 coroutine 은 non-blocking 이다. 즉, coroutine 이 완료될 때까지 thread 가 멈춰있지 않고 다른 작업을 처리할 수 있다. 아래 예시를 보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">showOrderInfo</span>(details: Details) = async {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> orderId = orderProduct(details).await()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> orderData = loadOrderData(orderId).await()
</span></span><span style="display:flex;"><span>    showData(orderData)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>위 예시에서 <code>orderProduct()</code> 와 <code>loadOrderData()</code> 는 suspend fun 로서, non-blocking 이다. 덕분에 thread 는 <code>showOrderInfo()</code> 함수 말고도 다른 작업을 할 수 있다. 만약 <code>orderProduct()</code> 와 <code>loadOrderData()</code> 가 blocking 이라면, thread 는 두 함수가 완료될 때까지 다른 작업을 할 수 없다.</p>
<h2 id="프로그래머가-편하다">프로그래머가 편하다<a hidden class="anchor" aria-hidden="true" href="#프로그래머가-편하다">#</a></h2>
<p>Coroutine 을 사용하는 함수를 정의할 때 suspend modifier 만 붙이면 된다. 그렇기 때문에 레거시 코드에 coroutine 을 도입할 때도 작업량이 적다.</p>
<p>callback 을 짤 필요가 없어서 코드의 가독성이 좋다. 후술하겠지만, 사실 Kotlin coroutine 은 callback 을 사용한다.</p>
<h2 id="퍼포먼스가-좋다">퍼포먼스가 좋다<a hidden class="anchor" aria-hidden="true" href="#퍼포먼스가-좋다">#</a></h2>
<p>Thread 를 생성하는 로직과 Thread 생성 없이 coroutine 을 실행하는 것의 성능 차이를 보자. 아래는 Marcin Moskała 의 Kotlin Coroutines Deep Dive 예시를 각색한 것이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">repeatWithThread</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> timeSpent = measureTimeMillis {
</span></span><span style="display:flex;"><span>        repeat(<span style="color:#ae81ff">400</span>_000) {
</span></span><span style="display:flex;"><span>            thread {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Thread</span>.sleep(<span style="color:#ae81ff">1500L</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println(<span style="color:#e6db74">&#34;Repeating with threads spent </span><span style="color:#e6db74">$timeSpent</span><span style="color:#e6db74"> milliseconds.&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>Repeating with threads spent 101091 milliseconds.
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">repeatWithCoroutine</span>() = runBlocking {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> timeSpent = measureTimeMillis {
</span></span><span style="display:flex;"><span>        repeat(<span style="color:#ae81ff">400</span>_000) {
</span></span><span style="display:flex;"><span>            launch {
</span></span><span style="display:flex;"><span>                delay(<span style="color:#ae81ff">1500L</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println(<span style="color:#e6db74">&#34;Repeating with coroutines spent </span><span style="color:#e6db74">$timeSpent</span><span style="color:#e6db74"> milliseconds.&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>Repeating with coroutines spent 178 milliseconds.
</span></span></code></pre></div><p>보다시피 thread 를 만드는 방식은 coroutine 을 사용하는 것보다 시간이 훨씬 많이 걸린다. 또한 thread 를 만들면서 OOM 이 발생할 수도 있다. 그러면 이미 thread pool 이 만들어진 상황에서는 어떨까? 아래를 보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">repeatWithThreadPool</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> threadPool = List(<span style="color:#ae81ff">400</span>_000) {
</span></span><span style="display:flex;"><span>            thread {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Thread</span>.sleep(<span style="color:#ae81ff">1500L</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> timeSpent = measureTimeMillis {
</span></span><span style="display:flex;"><span>            threadPool.forEach { <span style="color:#66d9ef">it</span>.join() }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        println(<span style="color:#e6db74">&#34;Repeating with threads spent </span><span style="color:#e6db74">$timeSpent</span><span style="color:#e6db74"> milliseconds.&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>Repeating with threads spent 2557 milliseconds.
</span></span></code></pre></div><p>위에서 확인할 수 있듯이, thread pool 을 만드는 시간을 재지 않았음에도 작업마다 thread 를 할당하는 방식은 coroutine 을 사용하는 방식보다 느리다.</p>
<h1 id="기본">기본<a hidden class="anchor" aria-hidden="true" href="#기본">#</a></h1>
<h2 id="개념">개념<a hidden class="anchor" aria-hidden="true" href="#개념">#</a></h2>
<p>Marcin Moskała 의 Kotlin Coroutines Deep Dive 에서 아래와 같이 coroutines 를 정의한다.</p>
<blockquote>
<p>By definition, coroutines are components that can be suspended and resumed.</p>
</blockquote>
<p>Kotlin coroutine 은 suspend, resume 이 가능하며 이 때의 동작은 non-blocking 이다. 또한 프로그래머는 어떤 thread 에서 coroutine 을 구동할지 선택할 수 있다.</p>
<h2 id="동작-예시-sequence">동작 예시: sequence<a hidden class="anchor" aria-hidden="true" href="#동작-예시-sequence">#</a></h2>
<p>아래는 Marcin Moskała 의 Kotlin Coroutines Deep Dive 예시다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CoroutineInSequence</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">showHowCoroutineWorks</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> seq = sequence {
</span></span><span style="display:flex;"><span>            println(<span style="color:#e6db74">&#34;Generating first&#34;</span>)
</span></span><span style="display:flex;"><span>            yield(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            println(<span style="color:#e6db74">&#34;Generating second&#34;</span>)
</span></span><span style="display:flex;"><span>            yield(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>            println(<span style="color:#e6db74">&#34;Generating third&#34;</span>)
</span></span><span style="display:flex;"><span>            yield(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>            println(<span style="color:#e6db74">&#34;Done&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (num <span style="color:#66d9ef">in</span> seq) {
</span></span><span style="display:flex;"><span>            println(<span style="color:#e6db74">&#34;the next number is </span><span style="color:#e6db74">$num</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>함수 <code>showHowCoroutineWorks()</code> 를 실행하면 아래와 같은 동작을 확인할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>Generating first
</span></span><span style="display:flex;"><span>the next number is 1
</span></span><span style="display:flex;"><span>Generating second
</span></span><span style="display:flex;"><span>the next number is 2
</span></span><span style="display:flex;"><span>Generating third
</span></span><span style="display:flex;"><span>the next number is 3
</span></span><span style="display:flex;"><span>Done
</span></span></code></pre></div><p>이를 통해 for-loop block 이 실행될 때마다 <code>yield()</code> 함수에서 코루틴이 멈추고 (suspend) 재개하는 (resume) 것을 확인할 수 있다.</p>
<p>참고로 suspend 대상은 함수가 아닌 coroutine 이라는 것을 잊으면 안 된다. 함수가 멈추는 것처럼 보여도, 이건 함수가 coroutine 을 멈춘 것이다.</p>
<h2 id="동작-원리-continuation-interface">동작 원리: Continuation interface<a hidden class="anchor" aria-hidden="true" href="#동작-원리-continuation-interface">#</a></h2>
<h2 id="callback-과-유사하다">Callback 과 유사하다<a hidden class="anchor" aria-hidden="true" href="#callback-과-유사하다">#</a></h2>
<p>Coroutine 은 어떻게 함수 중간에 실행을 멈추고, 나중에 멈춘 부분부터 실행할 수 있을까? Kotlin coroutines 의 동작 방식은 callback 과 유사하다. 하지만 Kotlin coroutine 은 thread 를 점유하지 않기 위해 call stack 을 비워버린다. 그렇기 때문에 call stack 의 대체제가 필요하다. 이는 continuations 에 의해 달성된다.</p>
<p>알다시피, suspend fun 은 suspension 과 resume 이 가능하다. 이를 위해서 기록돼야 하는 것들은 어느 함수 어느 위치에서 suspension 이 일어났는지, local variables, parameters 등이다. 당연한 얘기지만 이 정보를 갖고 resume 을 한다. 이 정보는 모두 Continuation object 에 저장된다.</p>
<p>Koltin compiler 는 suspend fun 에 Continuation interface 를 parameter 로 추가한다. Coninuation 은 general callback interface 다. 이는 IntelliJ 에서 kotlin code 를 java 로 변환해서 쉽게 확인할 수 있다.<br>
kotlin 코드</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">suspend</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">showContinuationParameter</span>() {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>java 로 변환</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SuspendFunctionPracticeKt</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">@Nullable</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Object <span style="color:#a6e22e">showContinuationParameter</span><span style="color:#f92672">(</span><span style="color:#a6e22e">@NotNull</span> Continuation $completion<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> Unit<span style="color:#f92672">.</span><span style="color:#a6e22e">INSTANCE</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>위 코드를 보면 suspend fun 에는 Continuation 이 있음을 알 수 있다.</p>
<h2 id="continuation-callback-절차">continuation callback 절차<a hidden class="anchor" aria-hidden="true" href="#continuation-callback-절차">#</a></h2>
<p>Continuation 의 callback 절차는 다음과 같다.</p>
<ol>
<li>continuation resume 시작</li>
<li>Resumed continuation 이 관련 함수를 호출</li>
<li>위 continuation 이 다른 continuation 을 resume 시킴</li>
</ol>
<p>위 절차가 연쇄적으로 일어난다. 아래 예시를 보자 (Marcin Moskała 의 Kotlin Coroutines Deep Dive 예시).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">suspend</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">a</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> user = readUser()
</span></span><span style="display:flex;"><span>    b()
</span></span><span style="display:flex;"><span>    b()
</span></span><span style="display:flex;"><span>    b()
</span></span><span style="display:flex;"><span>    println(user)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">suspend</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">b</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1.</span>.<span style="color:#ae81ff">10</span>) {
</span></span><span style="display:flex;"><span>        c(i)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">suspend</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">c</span>(i: Int) {
</span></span><span style="display:flex;"><span>    delay(i * <span style="color:#ae81ff">100L</span>)
</span></span><span style="display:flex;"><span>    println(<span style="color:#e6db74">&#34;Tick&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>위 코드에서 c 를 resume 하는 경우를 예로 들면 아래와 같은 절차가 연쇄적으로 일어난다.</p>
<ol>
<li>CContinuation.resume 호출</li>
<li>CContinuation.resume 이 c() 호출</li>
<li>c() 가 완료되면 CContinuation.resume 이 BContinuation.resume 호출</li>
</ol>
<p>동일한 절차로 AContinuation 까지 진행된다.</p>
<h1 id="convention-suspend-vs-extension">Convention: suspend vs. extension<a hidden class="anchor" aria-hidden="true" href="#convention-suspend-vs-extension">#</a></h1>
<p>Svetlana Isakova 는 suspend 함수를 언제 쓰고, 언제 CoroutineScope extension function 을 사용할지를 정한다. 반환 값을 즉시 확인하고자 할 때는 suspend fun 을 정의하고, 반환 값에 관심이 없거나 즉시 확인할 필요가 없을 때는 CoroutineScope 의 extension function 을 정의한다. 아래와 같이 말이다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">suspend</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">orderProduct</span>(details: details): ProductId
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">CoroutineScope</span>.loadProductInformationAsync(
</span></span><span style="display:flex;"><span>    productName: String
</span></span><span style="display:flex;"><span>): Deferred&lt;Image&gt;
</span></span></code></pre></div><h1 id="basic-example">Basic example<a hidden class="anchor" aria-hidden="true" href="#basic-example">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CoroutineBasic</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">executeMultipleCoroutine</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GlobalScope</span>.launch {
</span></span><span style="display:flex;"><span>            launch {
</span></span><span style="display:flex;"><span>                delay(<span style="color:#ae81ff">300L</span>)
</span></span><span style="display:flex;"><span>                println(<span style="color:#e6db74">&#34;1st scope: 1st coroutine&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            launch {
</span></span><span style="display:flex;"><span>                delay(<span style="color:#ae81ff">100L</span>)
</span></span><span style="display:flex;"><span>                println(<span style="color:#e6db74">&#34;1st scope: 2nd coroutine&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GlobalScope</span>.launch {
</span></span><span style="display:flex;"><span>                println(<span style="color:#e6db74">&#34;2nd scope: 1st println&#34;</span>)
</span></span><span style="display:flex;"><span>                println(<span style="color:#e6db74">&#34;2nd scope: 2nd println&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>executeMultipleCoroutine</code> 를 실행하면 다음과 같은 결과를 얻는다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>2nd scope: 1st println
</span></span><span style="display:flex;"><span>2nd scope: 2nd println
</span></span><span style="display:flex;"><span>1st scope: 2nd coroutine
</span></span><span style="display:flex;"><span>1st scope: 1st coroutine
</span></span></code></pre></div><p>즉, <code>launch</code> 함수 내에서는 synchronous, <code>launch</code> 함수끼리는 asynchronous 다.</p>
<h1 id="launch-vs-async">launch vs. async<a hidden class="anchor" aria-hidden="true" href="#launch-vs-async">#</a></h1>
<p>Coroutine builders 에는 <code>launch</code>, <code>async</code> 가 있다. <code>launch</code> 는 Job 을 반환하고, <code>async</code> 는 Deferred 를 반환한다. 어떤 경우에 <code>launch</code>, <code>async</code> 를 각각 사용해야 할까? 실행의 결과를 확인해야 하면 <code>async</code> 를, 실행만 하려면 <code>launch</code> 를 쓴다.</p>
<h1 id="적용-사례">적용 사례<a hidden class="anchor" aria-hidden="true" href="#적용-사례">#</a></h1>
<p>Philipp Lackner 가 youtube 에서 언급한 내용을 정리했다.</p>
<h2 id="예외-전파-exceptions-in-child-coroutines-propagate-to-the-parent">예외 전파: Exceptions in child coroutines propagate to the parent<a hidden class="anchor" aria-hidden="true" href="#예외-전파-exceptions-in-child-coroutines-propagate-to-the-parent">#</a></h2>
<p>코틀린 코루틴을 사용할 때 예외 처리가 헷갈릴 수 있다. 아래 두 함수를 보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CoroutineError</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">throwInsideCurrentCoroutine</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GlobalScope</span>.launch {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> Exception(<span style="color:#e6db74">&#34;exception.&#34;</span>)
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (e: Exception) {
</span></span><span style="display:flex;"><span>                println(<span style="color:#e6db74">&#34;Exception has been caught: </span><span style="color:#e6db74">$e</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">throwOutsideCurrentCoroutine</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GlobalScope</span>.launch {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                launch {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">throw</span> Exception(<span style="color:#e6db74">&#34;child coroutine exception thrown.&#34;</span>)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">catch</span> (e: Exception) {
</span></span><span style="display:flex;"><span>                println(<span style="color:#e6db74">&#34;Exception has been caught: </span><span style="color:#e6db74">$e</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>throwInsideCurrentCoroutine</code> 와 <code>throwOutsideCurrentCoroutine</code> 의 차이는 예외가 어디서 발생했느냐다. 전자는 try-catch 문이 속한 context 에서 예외가 발생하지만, 후자는 try-catch 가 속하지 않은 context 에서 예외가 발생한다. 그렇기 때문에 각 함수를 실행해보면 각각 아래와 같은 메시지를 확인할 수 있다.</p>
<p>함수 throwInsideCurrentCoroutine 실행: catch 성공</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>Exception has been caught: java.lang.Exception: nested exception.
</span></span></code></pre></div><p>함수 throwOutsideCurrentCoroutine 실행: catch 실패</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>Exception in thread &#34;DefaultDispatcher-worker-2&#34; java.lang.Exception: child coroutine exception thrown.
</span></span><span style="display:flex;"><span>	at CoroutineError$throwOutsideCurrentCoroutine$1$1.invokeSuspend(CoroutineError.kt:19)
</span></span><span style="display:flex;"><span>	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684)
</span></span><span style="display:flex;"><span>	Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@792a55e5, Dispatchers.Default]
</span></span></code></pre></div><p>함수 <code>throwOutsideCurrentCoroutine</code> 에서 왜 catch 가 실패할까? 이유는 서로 coroutine 이 다르기 때문이다. 코드에서 try 문 안에 <code>launch</code> 함수를 사용해 독립적인 coroutine 을 만들었고, 거기서 예외가 발생했으니 parent coroutine 로 propagation 이 일어나고, 이로 인해 catch 실패가 일어난다.</p>
<p><code>launch</code> 말고 <code>async</code> 는 어떨까? <code>async</code> 는 <code>await</code> 를 호출했을 때 <code>async</code> 내에서 발생한 exception 을 던진다. 그렇다면 아래 <code>throwAsyncExceptionInLaunch</code> 함수는 exception 을 던지면 안 될 거 같다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AsyncExceptionPractice</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">throwAsyncExceptionInLaunch</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GlobalScope</span>.launch {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> networkResponse = async {
</span></span><span style="display:flex;"><span>                delay(<span style="color:#ae81ff">500L</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> Exception()
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;result&#34;</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// No matter whether you comment this out, an exception occurs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//            networkResponse.await()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">throwAsyncExceptionInAsync</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GlobalScope</span>.async {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> networkResponse = async {
</span></span><span style="display:flex;"><span>                delay(<span style="color:#ae81ff">500L</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">throw</span> Exception()
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;result&#34;</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// No matter whether you comment this out, an exception does not occur
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//            networkResponse.await()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>하지만 <code>throwAsyncExceptionInLaunch</code> 함수를 호출하면 아래와 같이 exception 이 발생한다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>Exception in thread &#34;DefaultDispatcher-worker-2&#34; java.lang.Exception
</span></span><span style="display:flex;"><span>	at AsyncExceptionPractice$throwAsyncExceptionInLaunch$1$networkResponse$1.invokeSuspend(AsyncExceptionPractice.kt:11)
</span></span><span style="display:flex;"><span>	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684)
</span></span><span style="display:flex;"><span>	Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@45e5831c, Dispatchers.Default]
</span></span></code></pre></div><p>왜 그럴까? 함수 <code>throwAsyncExceptionInLaunch</code> 에서 <code>async</code> coroutine 이 <code>launch</code> coroutine 의 child 이기 때문이다. 다시 말하면, <code>launch</code> coroutine 으로 <code>async</code> coroutine 의 예외가 전파되고, <code>launch</code> 는 <code>async</code> 와 달리 즉시 예외를 던지기 때문이다.</p>
<p>만약 parent coroutine 이 <code>async</code> 에 의해 시작되는 <code>throwAsyncExceptionInAsync</code> 를 호출하면 어떤 일이 일어날까? 예외는 발생하지 않는다. 이는 위에서 서술한 <code>async</code> 의 성격과 관련이 있다.</p>
<h2 id="supervisorscope-no-propagation">supervisorScope: No propagation<a hidden class="anchor" aria-hidden="true" href="#supervisorscope-no-propagation">#</a></h2>
<p>Coroutine scope 는 propagation 방식에 따라 두 가지로 나뉜다. 하나는 (normal) coroutine scope, 다른 하나는 supervisor coroutine scope 이다. 보통의 coroutine scope 에서 예외가 발생하면 child coroutines 를 모두 취소하고 해당 coroutine scope 역시 취소된다. <code>supervisorScope</code> 는 child coroutine 의 예외가 전파되지 않는다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExceptionPropagationControl</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">doNotPropagate</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GlobalScope</span>.launch {
</span></span><span style="display:flex;"><span>            supervisorScope {
</span></span><span style="display:flex;"><span>                launch {
</span></span><span style="display:flex;"><span>                    delay(<span style="color:#ae81ff">300L</span>)
</span></span><span style="display:flex;"><span>                    println(<span style="color:#e6db74">&#34;1st coroutine.&#34;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">throw</span> Exception()
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                launch {
</span></span><span style="display:flex;"><span>                    delay(<span style="color:#ae81ff">500L</span>)
</span></span><span style="display:flex;"><span>                    println(<span style="color:#e6db74">&#34;2nd coroutine.&#34;</span>)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">doPropagate</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GlobalScope</span>.launch {
</span></span><span style="display:flex;"><span>            coroutineScope {
</span></span><span style="display:flex;"><span>                launch {
</span></span><span style="display:flex;"><span>                    delay(<span style="color:#ae81ff">300L</span>)
</span></span><span style="display:flex;"><span>                    println(<span style="color:#e6db74">&#34;1st coroutine.&#34;</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">throw</span> Exception()
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                launch {
</span></span><span style="display:flex;"><span>                    delay(<span style="color:#ae81ff">500L</span>)
</span></span><span style="display:flex;"><span>                    println(<span style="color:#e6db74">&#34;2nd coroutine.&#34;</span>)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>supervisorScope</code> 를 사용하는 <code>doNotPropagate()</code> 함수를 호출하면 child coroutine 의 예외가 전파되지 않는 것을 아래에서 확인할 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>1st coroutine.
</span></span><span style="display:flex;"><span>Exception in thread &#34;DefaultDispatcher-worker-2&#34; java.lang.Exception
</span></span><span style="display:flex;"><span>	at ExceptionPropagationControl$doNotPropagate$1$1$1.invokeSuspend(ExceptionPropagationControl.kt:19)
</span></span><span style="display:flex;"><span>	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684)
</span></span><span style="display:flex;"><span>	Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@386429a2, Dispatchers.Default]
</span></span><span style="display:flex;"><span>2nd coroutine.
</span></span></code></pre></div><p>반대로 <code>coroutineScope</code> 를 사용하는 <code>doPropagate()</code> 함수를 호출하면 아래와 같이 예외가 전파돼 다른 child coroutine 이 완료되지 않는다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>1st coroutine.
</span></span><span style="display:flex;"><span>Exception in thread &#34;DefaultDispatcher-worker-2&#34; java.lang.Exception
</span></span><span style="display:flex;"><span>	at ExceptionPropagationControl$doPropagate$1$1$1.invokeSuspend(ExceptionPropagationControl.kt:36)
</span></span><span style="display:flex;"><span>	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:108)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:584)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:793)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:697)
</span></span><span style="display:flex;"><span>	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:684)
</span></span><span style="display:flex;"><span>	Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@52d8bbd8, Dispatchers.Default]
</span></span></code></pre></div><h2 id="cancellation-bad-practice">cancellation bad practice<a hidden class="anchor" aria-hidden="true" href="#cancellation-bad-practice">#</a></h2>
<p>아래 코드를 보면 <code>cancel()</code> 을 통해 <code>targetJob</code> 이 취소됨을 알 수 있다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CoroutineCancellation</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">cancelJobDuringExecution</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">GlobalScope</span>.launch {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">val</span> targetJob = launch {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    delay(<span style="color:#ae81ff">500L</span>)
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (e: Exception) {
</span></span><span style="display:flex;"><span>                    e.printStackTrace()
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                println(<span style="color:#e6db74">&#34;job has been done.&#34;</span>)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            delay(<span style="color:#ae81ff">300L</span>)
</span></span><span style="display:flex;"><span>            targetJob.cancel()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-console" data-lang="console"><span style="display:flex;"><span>kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=StandaloneCoroutine{Cancelling}@25f78d6e
</span></span><span style="display:flex;"><span>job has been done.
</span></span></code></pre></div><p>위에서 <code>cancel()</code> 함수는 <code>targetJob</code> 을 300ms 후에 취소한다. <code>targetJob</code> 이 <code>println(&quot;job has been done.&quot;)</code> 을 실행하기 위해서는 500ms 가 필요하다. 그런데 이상하게도 console 은 &ldquo;job has been done.&rdquo; 를 출력한다. 왜 그럴까? <code>cancel()</code> 로 인해 <code>CancellationException</code> 이 발생하고, 이게 catch block 에서 잡히기 때문이다. <code>cancel()</code> 은 suspend 함수를 취소하는데, 위에서는 <code>delay(500L)</code> 이 취소된다. <code>delay(500L)</code> 이 취소되면서 <code>CancellationException</code> 이 발생하고, 이건 다시 catch block 에 의해 처리된다. 예외가 catch block 에서 잡혔기 때문에 parent coroutine 으로 예외는 전파되지 않는다. 그렇기 때문에 <code>println(&quot;job has been done.&quot;)</code> 이 실행되 자원이 낭비된다.</p>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<ul>
<li>Marcin Moskała. (2023) Kotlin Coroutines Deep Dive. Leanpub</li>
<li><a href="https://youtu.be/BXwuYykIxbk?si=kKffwwjqybCdZ4S8">Kotlin Coroutines, Google Developer Groups - Youtube</a></li>
<li><a href="https://www.youtube.com/watch?v=VWlwkqmTLHc">In-Depth Guide to Coroutine Cancellation &amp; Exception Handling - Android Studio Tutorial, Philipp Lackner - Youtube</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://Scoobi-wisdoom.github.io/">wisdoom</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
